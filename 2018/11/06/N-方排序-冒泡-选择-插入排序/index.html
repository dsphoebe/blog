<!Doctype html>
<html>
  <head>
  <meta charset="utf-8">
  
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <title>n 方排序：冒泡、选择、插入排序 | FE NOTEBOOK</title>
  
    <link rel="icon" href="/images/favico.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/style/style.css">
</head>
  <body>
    <header class="header">
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">首页</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">归档</a>
        </li>
      
    </ul>
  </nav>
  <h1>a[herf=&#34;code.dsphoebe.com&#34;]{FE NOTEBOOK}</h1>
  <em>「 困住你的从来都是你自己！」</em>
</header>
    <main class="main">
      <article class="post">
  <div class="post-title">
    <h2 class="title">n 方排序：冒泡、选择、插入排序</h2>
  </div>
  <div class="post-meta">
    <span class="post-time">2018-11-07 11:04:25</span>
    <span class="post-tags">
      
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/伪代码/">伪代码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/冒泡排序/">冒泡排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/插入排序/">插入排序</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/流程图/">流程图</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/选择排序/">选择排序</a></li></ul>
      
    </span>
    
  </div>
  <div class="post-content">
    <h2 id="什么是结构化编程"><a href="#什么是结构化编程" class="headerlink" title="什么是结构化编程"></a>什么是结构化编程</h2><p>一种编程范式。它采用子程序、代码区块、for 循环以及 while 循环等结构来取代 goto 指令的程序。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>仅有一个入口</li>
<li>仅有一个出口</li>
<li>结构中任一部分都应有执行到的机会</li>
<li>不出现死循环</li>
</ul>
<p>结构化编程描述算法的方法：伪代码，流程图。</p>
<p>以下写画下常见的九大排序算法的伪代码和流程图，还有 JavaScript 的实现。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>两两比较，大的往后排。第 1 项 与 第 2 项，大的往后；然后第 2 项 与 第 3 项比较，大的往后；然后第 3 项 与 第 4 项比较，大的往后排；然后第 4 项与第 5 项比较，大的往后排；…直到第 n 项 完成一轮排序。</p>
<p>进行下一轮排序时，可以确定前一轮已经确定了数组后面的轮数的项已经排好了，就不需要再进行排序。</p>
<p>…… 以此类推完成 n - 1 轮排序</p>
<p>流程图</p>
<p><img src="https://i.loli.net/2018/10/22/5bcd6ed2561e5.jpg" alt="1271540189276_.pic.jpg"></p>
<p>伪代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !arr || !arr.length</span><br><span class="line">  print arr</span><br><span class="line">end</span><br><span class="line">loopTimes &lt;- <span class="number">1</span></span><br><span class="line">arrLen &lt;- arr[<span class="string">'length'</span>]</span><br><span class="line">i &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> loopTimes &lt; arrLen</span><br><span class="line">  <span class="comment">// arrLen - loopTimes 是每一次循环都能确定一个当前循环的最大值，</span></span><br><span class="line">  <span class="comment">// 下次再循环的时候，可以减少一次循环</span></span><br><span class="line">  <span class="keyword">while</span> i &lt; arrLen - loopTimes</span><br><span class="line">    <span class="keyword">if</span> arr[i] &gt; arr[i + <span class="number">1</span>]</span><br><span class="line">      t &lt;- arr[i]</span><br><span class="line">      arr[i] &lt;- arr[i + <span class="number">1</span>]</span><br><span class="line">      arr[i + <span class="number">1</span>] &lt;- arr[i]</span><br><span class="line">      i &lt;- i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      i &lt;- i + <span class="number">1</span></span><br><span class="line">    end</span><br><span class="line">    loopTimes &lt;- loopTimes + <span class="number">1</span></span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">print arr</span><br></pre></td></tr></table></figure>
<p>JavaScript 实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr || !arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> arrLen = arr.length</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> loopTimes = <span class="number">1</span>; loopTimes &lt; arrLen; loopTimes++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLen - loopTimes; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">          [arr[i], arr[i + <span class="number">1</span>]] = [arr[i + <span class="number">1</span>], arr[i]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 loopTimes 等于 1 的循环完成后，数据并没有交换，那么就可以确定数组是有序的，不需要再进行之前的比较了，可以定义一个变量 swapFlag，标记是否发生交换，如果没有交换就直接退出程序。</p>
<p>JavaScript 优化实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bubbleSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr || !arr.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> arrLen = arr.length</span><br><span class="line">  <span class="keyword">let</span> swapFlag = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> loopTimes = <span class="number">1</span>; loopTimes &lt; arrLen; loopTimes++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLen - loopTimes; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        [arr[i], arr[i + <span class="number">1</span>]] = [arr[i + <span class="number">1</span>], arr[i]]</span><br><span class="line">        swapFlag = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (swapFlag == <span class="literal">false</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效率测试</p>
<p>随机生成一个长度为 100，最大值为 1000 的超大数组排序，通过 console.time 记录排序时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> randomArr = <span class="function">(<span class="params">arrLen = <span class="number">100</span>, maxValue = <span class="number">1000</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">    arr[i] = <span class="built_in">Math</span>.floor((maxValue + <span class="number">1</span>) * <span class="built_in">Math</span>.random())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = randomArr(<span class="number">1000</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'bubbleSort'</span>)</span><br><span class="line">bubbleSort(arr)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'bubbleSort'</span>)</span><br><span class="line"><span class="comment">// bubbleSort: 4.602783203125ms</span></span><br><span class="line"></span><br><span class="line">randomArr(<span class="number">10000</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'bubbleSort'</span>)</span><br><span class="line">bubbleSort(arr)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'bubbleSort'</span>)</span><br><span class="line"><span class="comment">// bubbleSort: 308.89599609375ms</span></span><br></pre></td></tr></table></figure>
<p>看起来数组长度增加 10 倍，排序时间增加差不多 100 倍。多次在 Chrome 上测试，却发现每次运行的时间不同，而且还出现了数组越长时间越短的情况。不知道是不是 V8 进行了优化。</p>
<p><img src="https://i.loli.net/2018/10/23/5bce9da0d814a.jpg" alt="1301540267403_.pic_hd.jpg"></p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>第一轮循环执行 是 n - 1<br>第二轮 n - 2<br>第三轮 n - 3<br>…<br>第 n 轮 n - n</p>
<p>得出 (n - 1) + (n - 2) + (n - 3)+…1 等差数列求和，即 n*(1 + (n -1)) /2。解开得到 n ^ 2 / 2，所以时间复杂度为 O(n^2)。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>循环<strong>选择出</strong>数组中的最大值，将最大值挪到数组最后；再进行下一次循环，选择出第二大的项…… 以此类推完成排序。或者循环选择出数组中的最小值，将最小值挪到数组最前面；再进行下一次循环，选择出第二小的项…… 以此类推完成排序。</p>
<p>伪代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !arr || !arr.length</span><br><span class="line">  print arr</span><br><span class="line">end</span><br><span class="line">loopTimes &lt;- <span class="number">1</span></span><br><span class="line">arrLen = arr[<span class="string">'length'</span>]</span><br><span class="line"><span class="keyword">while</span> loopTimes &lt; arrLen</span><br><span class="line">  maxPos &lt;- <span class="number">0</span></span><br><span class="line">  j &lt;- <span class="number">1</span></span><br><span class="line">  lastIndex &lt;- arrLen - loopTimes</span><br><span class="line">  <span class="keyword">while</span> j &lt;= lastIndex</span><br><span class="line">    <span class="keyword">if</span> arr[j] &gt; arr[maxPos]</span><br><span class="line">      maxPos &lt;- j</span><br><span class="line">      j &lt;- j + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      j &lt;- j + <span class="number">1</span></span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line">  <span class="keyword">if</span> maxPos != lastIndex</span><br><span class="line">    t &lt;- arr[lastIndex]</span><br><span class="line">    arr[lastIndex] &lt;- arr[maxPos]</span><br><span class="line">    arr[maxPos] &lt;- t</span><br><span class="line">    loopTimes &lt;- loopTimes + <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    loopTimes &lt;- loopTimes + <span class="number">1</span></span><br><span class="line">  end</span><br><span class="line">print arr</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>JavaScript 实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sectionSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr || !arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> arrLen = arr.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> loopTimes = <span class="number">1</span>; loopTimes &lt; arrLen; loopTimes++) &#123;</span><br><span class="line">        <span class="keyword">let</span> maxPos = <span class="number">0</span>,</span><br><span class="line">            lastIndex = arrLen - loopTimes;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= lastIndex; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[maxPos]) &#123;</span><br><span class="line">                maxPos = j</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxPos != lastIndex) &#123;</span><br><span class="line">            [arr[lastIndex], arr[maxPos]] = [arr[maxPos], arr[lastIndex]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每次循环获取最大值时，同时可以获取到最小值，可以通过这个来优化一下算法。</p>
<p>优化实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sectionSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> begin = <span class="number">0</span>,</span><br><span class="line">      end = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxPos = begin,</span><br><span class="line">        minPos = begin;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[maxPos]) &#123;</span><br><span class="line">        maxPos = i</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[minPos]) &#123;</span><br><span class="line">        minPos = i</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [arr[end], arr[maxPos]] = [arr[maxPos], arr[end]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (minPos == end) &#123;</span><br><span class="line">      minPos = maxPos</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [arr[begin], arr[minPos]] = [arr[minPos], arr[begin]]</span><br><span class="line"></span><br><span class="line">    begin++</span><br><span class="line">    end--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>类比扑克牌时，拿到牌后的整理牌的操作。第 2 个和第 1 个比较大小，排好序；第 3 个和前面两个比较，排好序；第 4 个和前面三个比较，排好序；以此类推。和前面已经排好序的元素序列中<strong>从后向前</strong>扫描。</p>
<p>伪代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">index &lt;- <span class="number">1</span></span><br><span class="line">arrLen &lt;- arr.length</span><br><span class="line"><span class="keyword">while</span> index &lt;= arrLen - <span class="number">1</span></span><br><span class="line">  last &lt;- index</span><br><span class="line">  tmp &lt;- arr[last]</span><br><span class="line">  <span class="keyword">while</span> last &gt; <span class="number">0</span> &amp;&amp; tmp &lt; arr[last<span class="number">-1</span>]</span><br><span class="line">    arr[last] &lt;- arr[last<span class="number">-1</span>]</span><br><span class="line">    last &lt;- last - <span class="number">1</span></span><br><span class="line">  end</span><br><span class="line">  arr[last] &lt;- tmp</span><br><span class="line">  index &lt;- index + <span class="number">1</span></span><br><span class="line">end</span><br><span class="line">print arr</span><br></pre></td></tr></table></figure>
<p>JavaScript 实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j - <span class="number">1</span>] &gt; tmp; j--) &#123;</span><br><span class="line">      arr[j] = arr[j - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j] = tmp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="splice-方法实现插入排序"><a href="#splice-方法实现插入排序" class="headerlink" title="splice 方法实现插入排序"></a>splice 方法实现插入排序</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> insertionSort = <span class="function"><span class="params">arr</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">        arr.splice(j, <span class="number">0</span>, arr[i])</span><br><span class="line">        arr.splice(i + <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://www.jianshu.com/p/5597bd9db39c" target="_blank" rel="noopener">伪·从零开始学算法 - 1.4 结构化编程与逻辑结构</a><br><a href="https://blog.csdn.net/qq_36528114/article/details/78685661" target="_blank" rel="noopener">九种常见排序的比较和实现</a><br><a href="https://jirengu.github.io/algorithm-you-should-know/zh-cn/sort-algorithm/" target="_blank" rel="noopener">排序算法</a></p>

  </div>
</article>
    </main>
    <footer>
  <p>&copy; 2017-2018 code.dsphoebe.com <a href="http://www.miitbeian.gov.cn/">京ICP备15048606号-1</a></p>
</footer>
  </body>
</html>
